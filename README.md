# Лабораторная работа №9-10: Продвинутое ООП на Kotlin
--- 
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированного
программирования в Kotlin.
---
## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевым
концепциям.
---
## Геттеры и сеттеры
1. Кастомные сеттеры с валидацией данных
2. Вычисляемые геттеры для динамических свойств
3. Приватные сеттеры для инкапсуляции

Пример:
```kotlin
var maxEnergy: Int = 100
    private set

var energy: Int = maxEnergy
    set(value) {
        field = value.coerceIn(0, maxEnergy)
    }
```
---
## Инкапсуляция
   Принцип ООП,скрывает внутреннее состояние объекта и защищает данные от некорректных изменений. 

Пример:
```kotlin
class OutpostWorker(val name: String) {
var energy: Int = 100
set(value) {
field = value.coerceIn(0..100)
}
```
---
## Data-классы
   Специальные классы с автоматической генерацией полезных методов

Пример:
```kotlin
data class OutpostResource(
    val id: Int,
    val name: String,
    var amount: Int
) {
    override fun toString(): String {
    return "Ресурс: $id | Имя: $name | Количество: $amount"
    }
}
```
---
## Абстрактные классы
   Базовые классы, которые нельзя создать напрямую, описывают общую логику и структуру.

Пример:
```kotlin
abstract class OutpostModule(
    val name: String,
    var level: Int = 1
) {
    fun upgrade() {
        level++
        println("$name повышен до уровня $level")
    }
}
```
---
## Интерфейсы
   Контракты поведения

Пример:
```kotlin
interface ModuleAction {
    fun execute(manager: ResourceManager)
}

interface Movable {
    var speed: Int
    fun move()
    fun stop() {
        println("Останавливаемся...")
    }
}
```
---
## Galaxy Outpost Manager
Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программирования и
архитектурные приёмы языка.
---
### Sealed-классы
Sealed-классы используются для представления ограниченного набора состояний или результатов, которые
известны на этапе компиляции.
Они позволяют:
* гарантировать обработку всех возможных вариантов;
* безопасно использовать конструкцию when без else;
* удобно описывать состояния, события и результаты действий.
---

### Пример: результат работы модуля
```kotlin
sealed-class ModuleResult {
    data class Success(val message: String) : ModuleResult()
    data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
    data class NotEnoughResources(
        val resourceName: String,
        val required: Int,
        val available: Int
    ) : ModuleResult()
    data class Error(val reason: String) : ModuleResult()
}
```
---
## Object в Kotlin
object - это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).
---
### Особенности:
* создаётся при первом обращении;
* существует в одном экземпляре;
* не имеет конструктора.
--- 

### Пример: глобальный логгер
```kotlin
object Logger {
    private var counter = 0
    fun log(message: String) {
        counter++
        println("[$counter] $message")
    }
}
```

### Использование:
```kotlin
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```

### object удобно использовать для:
* логгеров;
* конфигураций;
* состояний без данных в sealed-классах;
* утилитарных классов.
---

## Делегирование свойств
Делегирование свойств позволяет передать логику хранения и обработки значения другому объекту.

В Kotlin это реализуется с помощью ключевого слова **by**. 
Преимущества:
* уменьшение дублирования кода;
* централизованная логика проверки и обработки данных;
* более чистый и читаемый код.
* 
Пример: 
#### Ограничение диапазона значения энергии
```kotlin
var energy: Int by Delegates.observable(100) { _, old, new ->
println("Энергия изменилась: $old → $new")
}
```
#### Lazy (ленивая инициализация)
lazy позволяет инициализировать объект только при первом обращении к нему.
Это полезно, если:
* объект создаётся не всегда;
* его создание ресурсоёмкое;
* нужно отложить инициализацию.

Пример:
```kotlin
val resourceManager by lazy {
ResourceManager()
}
```
Объект ResourceManager будет создан только при первом использовании.
#### Observer-паттерн (наблюдатель)

Observer-паттерн позволяет объектам реагировать на изменения состояния другого объекта.
В проекте Galaxy Outpost Manager наблюдатели могут:
* реагировать на изменение ресурсов;
* логировать события;
* уведомлять пользователя.

Пример идеи:
1. ResourceManager изменяет ресурсы;
2. наблюдатель выводит сообщение в консоль при изменении.
3. Сохранение состояния
4. Для сохранения состояния проекта используется сериализация в JSON.

**Это позволяет:**

* сохранять данные между запусками программы
* хранить состояние в человекочитаемом формате
* легко перенести логику в Android-приложение

---
## Как запустить проект
1. Клонируйте репозиторий:
```bash
git https://github.com/Hig-lime-simp/Kotlin_Advanced_Lab_9_10_GROSHEV.git
```
1. Откройте проект в IntelliJ IDEA.
2. Запустите любой пример через контекстное меню или напрямую из `main`.
---
## Автор
Грошев Никита, also @higaaa, chairs/5
---
## Лицензия
Проект создан в учебных целях.
